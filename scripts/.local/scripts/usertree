#!/bin/sh

readonly table="%-70s %-10s %-10s %-14s %-5s"
readonly dtable="%-67s %-10s %-10s %-14s %-5s"

xdg_data="${XDG_DATA_HOME:-${HOME}/.local/share}"
s6_srcdir="$xdg_data/s6" # directory with inital s6 configs, svcs, and databases
s6_compdir="$s6_srcdir/rc/compiled" # compiled database directory
s6_dir="$XDG_RUNTIME_DIR/s6" # s6 data folder (scandir, livedir, logs, etc)
s6_scandir="$s6_dir/service" # s6 scandir
s6_livedir="$s6_dir/s6-rc" # s6-rc livedir
s6_svdirs="$s6_livedir/servicedirs" # s6-rc servicedir
s6_logger_dir="$s6_scandir/s6-svscan-log" # servicedir of catch-all logger
s6_logger_fifo="$s6_logger_dir/fifo" # fifo where all uncaught logs will go

boot_tree() {
    if s6-svscanctl -z "${s6_scandir}" 2>/dev/null; then
        echo "s6-svscan is already running on ${s6_scandir}, doing nothing"
        exit 1;
    fi
    rm -f "${s6_livedir}"
    rm -rf "${s6_scandir}"

    mkdir -p "$s6_scandir"
    mkdir -p "$s6_dir/log"
    cp -rL "$s6_srcdir/s6-svscan-log" "$s6_scandir"
    mkfifo "$s6_logger_fifo"
    
    setsid -f \
    fdmove -c 4 1 \
    redirfd -wnb 1 "$s6_logger_fifo" \
    fdmove -c 2 1 \
    envfile -I "$s6_srcdir/config/global.conf" \
    s6-svscan -d 4 "$s6_scandir" | read -r _

    s6-rc-init -c "$s6_compdir" -l "$s6_livedir" "$s6_scandir"
    
    s6-rc -l "$s6_livedir" start default
}

tear_tree(){
  s6-svc -d "$s6_logger_dir" # stop the catch-all logger first, or else it will ignore s6 shutdown and continue to run
  s6-svscanctl -t "$s6_scandir" # shut down the s6 tree
  rm -f "${s6_livedir}"
  rm -rf "${s6_scandir}"
}

recompile(){
    TS="$(date +%s)"
    NEW_DB="${s6_srcdir}/rc/compiled-$TS"
    SOURCES_SV="${s6_srcdir}/sv"
    SOURCES_BUNDLES="${s6_srcdir}/bundles"
    
    echo "Compiling new database to ${NEW_DB}..."
    set -x
    s6-rc-compile "$NEW_DB" "$SOURCES_SV" "$SOURCES_BUNDLES"
    result=$?
    set +x
    echo
    if [ "$result" -ne 0 ]; then
        echo "Failed to compile database!"
        exit 1
    fi
    
    if s6-svscanctl -z "${s6_scandir}" 2>/dev/null; then
        echo "Displaying what services will be stopped, and what services will be started"
        echo
        s6-rc-update -n -l "$s6_livedir" "$NEW_DB"
        echo
        echo "Enter YES in uppercase to confirm, enter anything else to decline"
        read -r apply
        if [ "${apply}" != "YES" ]; then
          echo "Database is saved and compiled, but system is not switched to it"
          exit 1
        fi
        echo "Switching to the new database"
        set -x
        s6-rc-update -l "$s6_livedir" "$NEW_DB"
        set +x
        echo
    else
        echo "s6-svscan is not running on ${s6_scandir}, skipping online database switching"
        echo
    fi
    echo "Updating symlink to the newly compiled database"
    set -x
    s6-ln -nsf "$NEW_DB" "$s6_compdir"
    set +x
    echo
    echo "Switched to the new database!"
}

service_up(){
    s6-rc -l "$s6_livedir" -v 2 start "$@"
}

service_down(){
    s6-rc -l "$s6_livedir" -v 2 stop "$@"
}

colorize() {
    # prefer terminal safe colored and bold text when tput is supported
    if tput setaf 0 >/dev/null; then
        ALL_OFF="$(tput sgr0)"
        BOLD="$(tput bold)"
        BLUE="${BOLD}$(tput setaf 4)"
        GREEN="${BOLD}$(tput setaf 2)"
        RED="${BOLD}$(tput setaf 1)"
        YELLOW="${BOLD}$(tput setaf 3)"
        WHITE="${BOLD}$(tput setaf 7)"
    else
        ALL_OFF="\e[0m"
        BOLD="\e[1m"
        BLUE="${BOLD}\e[34m"
        GREEN="${BOLD}\e[32m"
        RED="${BOLD}\e[31m"
        YELLOW="${BOLD}\e[33m"
        WHITE="${BOLD}\e[37m"
    fi
    readonly ALL_OFF BOLD BLUE GREEN RED YELLOW WHITE
}

if [ -t 2 ] && [ "$TERM" != dumb ]; then
    colorize
else
    # shellcheck disable=2034
    ALL_OFF='' BOLD='' BLUE='' GREEN='' RED='' YELLOW=''
fi

msg(){
    mesg=$1; shift
    # shellcheck disable=2059
    printf "${WHITE} ${mesg}${ALL_OFF}\n" "$@"
}

error(){
    mesg=$1; shift
    # shellcheck disable=2059
    printf "${RED} ERROR:${ALL_OFF} ${WHITE}${mesg}${ALL_OFF}\n" "$@"
    exit 1
}

row_header(){
    mesg=$1; shift
    # shellcheck disable=2059
    printf "${BLUE} ${mesg} ${ALL_OFF}\n" "$@"
}

row_up(){
    mesg=$1; shift
    # shellcheck disable=2059
    printf "${GREEN} ${mesg}${ALL_OFF}\n" "$@"
}

row_down(){
    mesg=$1; shift
    # shellcheck disable=2059
    printf "${RED} ${mesg}${ALL_OFF}\n" "$@"
}

row_dep(){
    mesg=$1; shift
    # shellcheck disable=2059
    printf "${WHITE} |__${mesg}${ALL_OFF}\n" "$@"
}

convert_t () {
    secs="$1"
    if [ "$secs" -eq 0 ]; then
        printf "0:00:00:00\n"
    else
        date -d "@$secs" "+$((secs/86400)):%H:%M:%S"
    fi
}

is_bundle() {
    for bundle in $(s6-rc-db -c "${s6_compdir}" list bundles); do
        if [ "$bundle" = "$BUNDLE" ]; then
            return 0
        fi
    done
    return 1
}

# $1 - bundle $2 show deps
show_bundle() {
    BUNDLE="$1"
    DEPS="$2"

    if ! is_bundle; then
        error "Bundle (%s) does not exist!" "$BUNDLE"
    fi

    msg "Bundle: %s" "$BUNDLE"
    row_header "$table" "service" "type" "pid" "time" "up"

    for sv in $(s6-rc-db -c "${s6_compdir}" contents "$BUNDLE"); do
        _type=''
        _type=$(s6-rc-db -c "${s6_compdir}" type "${sv}")
        if [ "$_type" = 'longrun' ]; then
            _stat='' _pid='' _time=''
            _stat=$(s6-svstat -u "${s6_svdirs}/$sv")
            _pid=$(s6-svstat -o pid "${s6_svdirs}/$sv")
            _time=$(s6-svstat -t "${s6_svdirs}/$sv")
            if "$_stat"; then
                row_up "$table" "$sv" "$_type" "$_pid" "$(convert_t "$_time")" "$_stat"
            else
                row_down "$table" "$sv" "$_type" "$_pid" "$(convert_t "$_time")" "$_stat"
            fi
            if [ "$DEPS" -eq 1 ]; then
                for d in $(s6-rc-db -c "${s6_compdir}" dependencies "$sv"); do
                    _type=$(s6-rc-db -c "${s6_compdir}" type "$d")
                    if [ "$_type" = 'longrun' ]; then
                        _stat=$(s6-svstat -u "${s6_svdirs}/$d")
                        _pid=$(s6-svstat -o pid "${s6_svdirs}/$d")
                        _time=$(s6-svstat -t "${s6_svdirs}/$d")
                        row_dep "$dtable" "$d" "$_type" "$_pid" "$(convert_t "$_time")" "$_stat"
                    elif [ "$_type" = 'oneshot' ]; then
                        row_dep "$dtable" "$d" "$_type" "" "" ""
                    fi
                done
            fi
        fi
    done
}


case "$1" in
    b)
        boot_tree 
    ;;
    t)
        tear_tree
    ;;
    r)
        recompile
    ;;
    s)
        BUNDLE="${2:-default}"
        SHOW_DEPS=0
        if [ "$3" == "d" ]; then
            SHOW_DEPS=1
        fi
        show_bundle "$BUNDLE" "$SHOW_DEPS"
    ;;
    u)
        shift
        service_up "$@"
    ;;
    d)
        shift
        service_down "$@"
    ;;
    *)
        printf "Usage: %s [command] <args>\n\n  u <svc1> <svc2> <svc3> - start service(s)\n  d <svc1> <svc2> <svc3> - stop service(s)\n  b - boot usertree\n  t - teardown usertree\n  r - recompile database and switch to it if usertree is running\n  s <bundle> <d> - show services status in bundle. If not specifided, 'default' bundle is used. add 'd' as second argument to show services dependencies\n\n" "$(basename "${0}")"
    ;;
esac

